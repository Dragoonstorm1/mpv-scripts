local utils = require 'mp.utils'
local seconds = 0
local countTimer = 0
local seekTime = 0

local seekNumber = 0
local currentIndex = 0
local seekTable = {}
local seeking=0

table.insert(seekTable,0,0)

mp.register_event('file-loaded', function()
	filePath = mp.get_property('path')

	timer = mp.add_periodic_timer(0.1, function()--for very accurate video time 0.1
		seconds = seconds + 0.1
	end)
	
	timer2 = mp.add_periodic_timer(0.1, function()--this does all the magic
		countTimer = countTimer + 0.1--this does all the magic #2 to make it detect seek-end event
		
	if countTimer == 0.6 then--if almost a second passed then take time and do all of the below
		if (seeking == 0) then--only do things if this is not triggered by a redo or undo
				seconds = seconds - countTimer -- decrease the delay out of seconds
				seekTable[currentIndex] = seekTable[currentIndex] + seconds --dynamic entry it will have the previousIndex + seconds
				
				seconds=0		
				seekNumber=currentIndex+1 --seekNumber is always ahead-- to make it act as the length of table (seekNumber becomes currentIndex+1)
				currentIndex=seekNumber --currentIndex should be updated with each seek, to identify our position (our current position in the table) -- currentIndex get updated also when redoing and undoing --seeknumber only when seeking with the bar (currentindex becomes seekNumber) overwriting of tables happens
				seekTime = math.floor(mp.get_property_number('time-pos')) --try to get the time when it is very close to one second -- make it dynamic and include the seconds
				table.insert(seekTable, seekNumber, seekTime)--now go to previous table and add the previous seekTime
		elseif seeking == 1 then
			seeking=0
		end
	end
		
	end)
	
	timer2:stop()--do not make timer2 work at the bginning only after seek
end)


mp.register_event('seek', function()--for now use seek even if it detects chapter(update it does not detect chapters! ^ ^)
	timer2:resume()--make timer 
	countTimer = 0 --reset counter to make it take the seekTime again when it becomes above THIS does all the magic #2 to make it detect seek-end event keep reseting counter and detect when it does not
	 --if the seeking happened twice in less than a second dont count it as seek or. THIS if almost second passed after seeking then take time
end)

mp.register_event('pause', function()
	timer:stop()--to handle accurate video playtime
end)

mp.register_event('unpause', function()
	timer:resume()--to handle accurate video playtime
end)

mp.register_event('end-file', function()
	timer:kill()--reset timer on video end
	timer2:kill()--reset timer on video end
	seekNumber = 0--reset seek number on video end
end)

mp.add_key_binding("ctrl+z", "undo", function()
	if (filePath ~= nil) and (currentIndex >= 1) and (seeking == 0) then--if seeknumber is more than 1 or equal it means there is undo position (added countTimer more than 5 so ctrl z only works when counter is after NEW seek is saved
		seconds = seconds - countTimer -- decrease the delay out of seconds
		seekTable[currentIndex] = seekTable[currentIndex] + seconds --add to the currentIndex which is the previous position the seconds
		seconds=0--now reset the seconds (since the seconds = 0 didnt run because of the firewall have to reset the time manually)

		currentIndex=currentIndex-1 --with seek command we tell it to go to the element in SeekTable at currentIndex position which has become 1 less, so it means go to the previous value, and the currentIndex is now 2

		mp.commandv('seek', seekTable[currentIndex], 'absolute', 'exact') --use the seektable for undo using the rules defined above
		seeking=1
		mp.osd_message('Undo Last Seek')
	end
end)
mp.add_key_binding("ctrl+y", "redo", function()
	if (filePath ~= nil) and (currentIndex < seekNumber) and (seeking == 0) then--if seeknumber is more than 1 or equal it means there is undo position (added countTimer more than 5 so ctrl z only works when counter is after NEW seek is saved--only when index is less than seekNumber than redo should exist
		seconds = seconds - countTimer -- decrease the delay out of seconds
		seekTable[currentIndex] = seekTable[currentIndex] + seconds
		seconds=0
		currentIndex=currentIndex+1
		seeking=1
		mp.commandv('seek', seekTable[currentIndex], 'absolute', 'exact') --use the seektable for undo using the rules defined above
		mp.osd_message('Redo Next Seek')
	end
end)
